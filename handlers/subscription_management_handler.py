# handlers/subscription_management_handler.py
import re
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ContextTypes, ConversationHandler, CommandHandler, 
    CallbackQueryHandler, MessageHandler, filters
)
from queries.user_queries import get_user_emails, add_user_email, delete_user_email
from queries.subscription_queries import get_user_subscriptions, delete_subscription, get_subscription_details
from logger import get_logger

logger = get_logger(__name__)
ADD_EMAIL = range(1)
EMAIL_REGEX = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'

# --- –§–£–ù–ö–¶–ò–Ø, –ö–û–¢–û–†–£–Æ –ù–ï –£–î–ê–ï–¢–°–Ø –ò–ú–ü–û–†–¢–ò–†–û–í–ê–¢–¨ ---
async def my_subscriptions_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.effective_user:
        return
    subs = await get_user_subscriptions(update.effective_user.id)
    keyboard = []
    text = "üìÇ *–í–∞—à–∏ –ø–æ–¥–ø–∏—Å–∫–∏*\n\n"
    if not subs:
        text += "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫."
    else:
        text += "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:"
        for sub in subs:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º sub.id –≤–º–µ—Å—Ç–æ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ sub.display_id
            keyboard.append([InlineKeyboardButton(f"{sub.subscription_name} ({sub.id})", callback_data=f"sub_menu_{sub.id}")]) 
    keyboard.append([InlineKeyboardButton("‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –ø–æ–¥–ø–∏—Å–∫—É", callback_data="create_sub_start")])
    await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')
# --------------------------------------------------

async def build_email_management_menu(telegram_id: int, intro_text: str) -> dict:
    user_emails = await get_user_emails(telegram_id)
    keyboard = []
    text = f"{intro_text}\n\n"
    if user_emails:
        text += "–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∞–¥—Ä–µ—Å–∞:\n"
        for email in user_emails:
            text += f"‚Ä¢ `{email.email}`\n"
            keyboard.append([InlineKeyboardButton(f"üóëÔ∏è –£–¥–∞–ª–∏—Ç—å {email.email}", callback_data=f"delete_email_{email.id}")])
    else:
        text += "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö email-–∞–¥—Ä–µ—Å–æ–≤.\n"
    keyboard.append([InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π Email", callback_data="add_email_start")])
    return {"text": text, "reply_markup": InlineKeyboardMarkup(keyboard)}

async def my_emails_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.effective_user or not update.message: return
    menu_data = await build_email_management_menu(update.effective_user.id, "üìß *–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ Email-–∞–¥—Ä–µ—Å–∞–º–∏*")
    await update.message.reply_text(menu_data["text"], reply_markup=menu_data["reply_markup"], parse_mode='Markdown')

async def delete_email_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.data or not query.from_user: return
    await query.answer()
    email_id = int(query.data.split("_")[-1])
    deleted = await delete_user_email(email_id, query.from_user.id)
    intro_text = "‚úÖ Email —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω." if deleted else "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å email."
    menu_data = await build_email_management_menu(query.from_user.id, intro_text)
    await query.edit_message_text(menu_data["text"], reply_markup=menu_data["reply_markup"], parse_mode='Markdown')

async def add_email_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query: return ConversationHandler.END
    await query.answer()
    await query.edit_message_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ email-–∞–¥—Ä–µ—Å, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å. –î–ª—è –æ—Ç–º–µ–Ω—ã –≤–≤–µ–¥–∏—Ç–µ /cancel.")
    return ADD_EMAIL

async def add_email_receive(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.text or not update.effective_user: return ConversationHandler.END
    email = update.message.text.strip()
    if not re.fullmatch(EMAIL_REGEX, email):
        await update.message.reply_text("‚õîÔ∏è –ö–∞–∂–µ—Ç—Å—è, —ç—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ email. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.")
        return ADD_EMAIL
    added_email = await add_user_email(update.effective_user.id, email)
    intro_text = f"‚úÖ –ù–æ–≤—ã–π email `{added_email.email}` —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω." if added_email else f"‚ö†Ô∏è Email `{email}` —É–∂–µ –±—ã–ª –≤ –≤–∞—à–µ–º —Å–ø–∏—Å–∫–µ."
    menu_data = await build_email_management_menu(update.effective_user.id, intro_text)
    await update.message.reply_text(menu_data["text"], reply_markup=menu_data["reply_markup"], parse_mode='Markdown')
    return ConversationHandler.END

# –ï–î–ò–ù–°–¢–í–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –û–¢–ú–ï–ù–´ –î–õ–Ø EMAIL
async def cancel_email_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û—Ç–º–µ–Ω—è–µ—Ç –≤–≤–æ–¥ email."""
    if not update.message: return ConversationHandler.END
    await update.message.reply_text("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    return ConversationHandler.END

def get_email_conversation_handler() -> ConversationHandler:
    return ConversationHandler(
        entry_points=[CallbackQueryHandler(add_email_start, pattern="^add_email_start$")],
        states={
            ADD_EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_email_receive)]
        },
        fallbacks=[
            CommandHandler("cancel", cancel_email_conversation),
        ],
    )

def get_email_command_handlers():
    return [
        CommandHandler("my_emails", my_emails_command),
        CallbackQueryHandler(delete_email_callback, pattern="^delete_email_"),
    ]


# --- –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –£–ü–†–ê–í–õ–ï–ù–ò–Ø –ü–û–î–ü–ò–°–ö–ê–ú–ò ---

async def subscription_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.data or not query.from_user:
        return
    await query.answer()
    subscription_id = int(query.data.split("_")[-1])
    sub = await get_subscription_details(subscription_id, query.from_user.id)
    if not sub:
        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –Ω–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –≤–∞–º.")
        return
    email_list = [e.email for e in sub.target_emails]
    emails_text = '`' + '`, `'.join(email_list) + '`' if email_list else '–¢–æ–ª—å–∫–æ –≤ Telegram'
    status_text = '–ê–∫—Ç–∏–≤–Ω–∞ ‚úÖ' if sub.is_active is True else '–ù–µ–∞–∫—Ç–∏–≤–Ω–∞ ‚è∏Ô∏è'
    containers_count = len(sub.containers) if sub.containers is not None else 0
    text = (
        f"‚öôÔ∏è *–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–æ–π:*\n"
        f"*{sub.subscription_name}* `({sub.id})`\n\n" 
        f"–°—Ç–∞—Ç—É—Å: {status_text}\n"
        f"–í—Ä–µ–º—è –æ—Ç—á–µ—Ç–∞: {sub.notification_time.strftime('%H:%M')}\n"
        f"–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤: {containers_count} —à—Ç.\n"
        f"Email –¥–ª—è –æ—Ç—á–µ—Ç–æ–≤: {emails_text}"
    )
    keyboard = [
        [InlineKeyboardButton("üìã –ü–æ–∫–∞–∑–∞—Ç—å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã", callback_data=f"sub_show_{sub.id}")],
        [InlineKeyboardButton("üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data=f"sub_delete_{sub.id}")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É", callback_data="sub_back_to_list")]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')

async def show_containers_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.data or not query.from_user:
        return
    await query.answer()
    subscription_id = int(query.data.split("_")[-1])
    sub = await get_subscription_details(subscription_id, query.from_user.id)
    if not sub:
        await query.answer("‚ùå –û—à–∏–±–∫–∞: –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", show_alert=True)
        return
    if not sub.containers or len(sub.containers) == 0:
        text = "–í —ç—Ç–æ–π –ø–æ–¥–ø–∏—Å–∫–µ –Ω–µ—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤."
    else:
        container_list = "\n".join(f"`{c}`" for c in sub.containers)
        text = f"–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã –≤ –ø–æ–¥–ø–∏—Å–∫–µ *{sub.subscription_name}*:\n{container_list}"
    if update.effective_chat:
        await context.bot.send_message(chat_id=update.effective_chat.id, text=text, parse_mode='Markdown')

async def delete_subscription_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.data or not query.from_user:
        return
    await query.answer()
    subscription_id = int(query.data.split("_")[-1])
    deleted = await delete_subscription(subscription_id, query.from_user.id)
    if deleted:
        await query.edit_message_text("‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞.")
    else:
        await query.edit_message_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É.")

async def back_to_subscriptions_list_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.from_user:
        return
    await query.answer()
    subs = await get_user_subscriptions(query.from_user.id)
    keyboard = []
    text = "üìÇ *–í–∞—à–∏ –ø–æ–¥–ø–∏—Å–∫–∏*\n\n"
    if not subs:
        text += "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫."
    else:
        text += "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:"
        for sub in subs:
            keyboard.append([InlineKeyboardButton(f"{sub.subscription_name} ({sub.id})", callback_data=f"sub_menu_{sub.id}")])
    keyboard.append([InlineKeyboardButton("‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –ø–æ–¥–ø–∏—Å–∫—É", callback_data="create_sub_start")])
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')


def get_subscription_management_handlers():
    return [
        CommandHandler("my_subscriptions", my_subscriptions_command),
        CallbackQueryHandler(subscription_menu_callback, pattern="^sub_menu_"),
        CallbackQueryHandler(show_containers_callback, pattern="^sub_show_"),
        CallbackQueryHandler(delete_subscription_callback, pattern="^sub_delete_"),
        CallbackQueryHandler(back_to_subscriptions_list_callback, pattern="^sub_back_to_list$"),
    ]