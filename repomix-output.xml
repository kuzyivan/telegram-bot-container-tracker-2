This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy.yml
.repomix/
  bundles.json
alembic/
  env.py
  README
  script.py.mako
handlers/
  admin_handlers.py
  broadcast.py
  tracking_handlers.py
  user_handlers.py
migrations/
  versions/
    03a7f0ead8f9_init.py
    b1b7c58c8ce4_add_users_table.py
  env.py
  README
  script.py.mako
utils/
  keep_alive.py
  keyboards.py
  send_tracking.py
.gitignore
alembic.ini
backup_db.py
bot.py
config.py
db.py
logger.py
mail_reader.py
models.py
README.md
requirements.txt
scheduler.py
test_db.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomix/bundles.json">
{
  "bundles": {
    "full_code_repomix-169": {
      "name": "full_code_repomix",
      "created": "2025-08-16T11:22:58.673Z",
      "lastUsed": "2025-08-16T11:22:58.673Z",
      "tags": [],
      "files": []
    }
  }
}
</file>

<file path="alembic/README">
Generic single-database configuration.
</file>

<file path="alembic/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    """Upgrade schema."""
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    """Downgrade schema."""
    ${downgrades if downgrades else "pass"}
</file>

<file path="migrations/README">
Generic single-database configuration.
</file>

<file path="migrations/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    """Upgrade schema."""
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    """Downgrade schema."""
    ${downgrades if downgrades else "pass"}
</file>

<file path="utils/keep_alive.py">
import os
import time
import requests
import threading
import logging

logger = logging.getLogger(__name__)

def keep_alive():
    url = f"https://{os.environ.get('RENDER_EXTERNAL_HOSTNAME')}/"
    def ping():
        while True:
            try:
                response = requests.get(url)
                logger.info(f"[AUTOPING] {url} ‚Äî {response.status_code}")
            except Exception as e:
                logger.warning(f"[AUTOPING] Error: {e}")
            time.sleep(600)
    threading.Thread(target=ping, daemon=True).start()
</file>

<file path="utils/keyboards.py">
from telegram import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton

# Reply-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ (–≤—Å–µ–≥–¥–∞ —Å–Ω–∏–∑—É)
reply_keyboard = ReplyKeyboardMarkup(
    [
        [KeyboardButton("üì¶ –î–∏—Å–ª–æ–∫–∞—Ü–∏—è")],
        [KeyboardButton("üîî –ó–∞–¥–∞—Ç—å —Å–ª–µ–∂–µ–Ω–∏–µ")],
        [KeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞ —Å–ª–µ–∂–µ–Ω–∏—è")]
    ],
    resize_keyboard=True
)

# Inline-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–∏—Ö –¥–µ–π—Å—Ç–≤–∏–π
dislocation_inline_keyboard = InlineKeyboardMarkup([
    [InlineKeyboardButton("–í–≤–µ—Å—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä", callback_data="dislocation_inline")]
])
tracking_inline_keyboard = InlineKeyboardMarkup([
    [InlineKeyboardButton("–í–≤–µ—Å—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä(—ã)", callback_data="track_request")]
])

# –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–º–µ–Ω—ã —Å–ª–µ–∂–µ–Ω–∏—è
cancel_tracking_confirm_keyboard = InlineKeyboardMarkup([
    [
        InlineKeyboardButton("‚úÖ –î–ê", callback_data="cancel_tracking_yes"),
        InlineKeyboardButton("‚ùå –ù–ï–¢", callback_data="cancel_tracking_no")
    ]
])

# –î–ª—è —Å—Ç–∞—Ä–æ–≥–æ main_menu_keyboard ‚Äî –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
main_menu_keyboard = InlineKeyboardMarkup([
    [InlineKeyboardButton("üöÄ –°—Ç–∞—Ä—Ç", callback_data='start')],
    [InlineKeyboardButton("üì¶ –î–∏—Å–ª–æ–∫–∞—Ü–∏—è", callback_data='dislocation')],
    [InlineKeyboardButton("üîî –ó–∞–¥–∞—Ç—å —Å–ª–µ–∂–µ–Ω–∏–µ", callback_data='track_request')],
])
# –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –º–µ–Ω—é
universal_menu_keyboard = InlineKeyboardMarkup([
    [InlineKeyboardButton("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data='start')],
    [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data='back')]
])
# –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –º–µ–Ω—é —Å –∫–Ω–æ–ø–∫–æ–π "–ù–∞–∑–∞–¥"
universal_menu_keyboard_with_back = InlineKeyboardMarkup([
    [InlineKeyboardButton("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data='start')],
    [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data='back')]
])
</file>

<file path="backup_db.py">
import os
import subprocess
import shutil
import time
from apscheduler.schedulers.background import BackgroundScheduler

# –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
GITHUB_REPO = os.getenv("GITHUB_BACKUP_REPO")
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
PG_DUMP_PATH = os.getenv("PG_DUMP_PATH", "pg_dump")  # –ø—É—Ç—å –∫ pg_dump –µ—Å–ª–∏ –Ω–µ –≤ PATH

# –ù–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ –¥–∞–º–ø–∞ –∏ –≤—Ä–µ–º–µ–Ω–Ω–∞—è –ø–∞–ø–∫–∞
BACKUP_FILENAME = "backup.dump"
CLONE_FOLDER = "backup_repo_clone"

def backup_database():
    if not GITHUB_REPO or not GITHUB_TOKEN:
        print("‚ùå –ù–µ—Ç GITHUB_BACKUP_REPO –∏–ª–∏ GITHUB_TOKEN.")
        return

    try:
        if os.path.exists(CLONE_FOLDER):
            shutil.rmtree(CLONE_FOLDER)

        clone_url = GITHUB_REPO.replace("https://", f"https://{GITHUB_TOKEN}@")
        subprocess.run(["git", "clone", clone_url, CLONE_FOLDER], check=True)

        backup_file_path = os.path.join(CLONE_FOLDER, BACKUP_FILENAME)

        pg_env = {
            "PGHOST": os.getenv("POSTGRES_HOST"),
            "PGPORT": os.getenv("POSTGRES_PORT", "5432"),
            "PGUSER": os.getenv("POSTGRES_USER"),
            "PGPASSWORD": os.getenv("POSTGRES_PASSWORD"),
        }
        db_name = os.getenv("POSTGRES_DB")

        dump_cmd = [
            PG_DUMP_PATH,
            "-Fc",  # custom —Ñ–æ—Ä–º–∞—Ç
            "-f", backup_file_path,
            db_name
        ]
        subprocess.run(dump_cmd, check=True, env={**os.environ, **pg_env})

        os.chdir(CLONE_FOLDER)
        subprocess.run(["git", "add", BACKUP_FILENAME], check=True)
        subprocess.run(["git", "commit", "-m", f"Backup {time.strftime('%Y-%m-%d %H:%M:%S')}"], check=True)
        subprocess.run(["git", "push"], check=True)
        os.chdir("..")
        shutil.rmtree(CLONE_FOLDER)

        print("‚úÖ –ë—ç–∫–∞–ø PostgreSQL –±–∞–∑—ã —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ GitHub.")
    except Exception as e:
        print(f"‚ùó –û—à–∏–±–∫–∞ –ø—Ä–∏ –±—ç–∫–∞–ø–µ: {e}")

def start_backup_scheduler():
    scheduler = BackgroundScheduler()
    scheduler.add_job(backup_database, "interval", hours=24)
    scheduler.start()
    print("üîÑ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –±—ç–∫–∞–ø–∞ –∑–∞–ø—É—â–µ–Ω.")
</file>

<file path="test_db.py">
from db import SessionLocal
from models import Tracking

def main():
    session = SessionLocal()
    try:
        new_entry = Tracking(container_number="TEST1234567")
        session.add(new_entry)
        session.commit()
        print("‚úÖ –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–æ–±–∞–≤–ª–µ–Ω:", new_entry.container_number)
    except Exception as e:
        print("‚ùå –û—à–∏–±–∫–∞:", e)
    finally:
        session.close()

if __name__ == "__main__":
    main()
</file>

<file path="migrations/versions/b1b7c58c8ce4_add_users_table.py">
"""add users table

Revision ID: b1b7c58c8ce4
Revises: 03a7f0ead8f9
Create Date: 2025-06-23 06:31:43.723429

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'b1b7c58c8ce4'
down_revision: Union[str, None] = '03a7f0ead8f9'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('username', sa.String(), nullable=True),
    sa.Column('email', sa.String(), nullable=True),
    sa.Column('email_enabled', sa.Boolean(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('telegram_id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('users')
    # ### end Alembic commands ###
</file>

<file path="utils/send_tracking.py">
import pandas as pd
from openpyxl.styles import PatternFill
from datetime import datetime, timedelta
import tempfile
import re
from logger import get_logger

logger = get_logger(__name__)

def create_excel_file(rows, columns):
    """
    –û–¥–Ω–æ–ª–∏—Å—Ç–æ–≤–æ–π Excel-—Ñ–∞–π–ª.
    rows: —Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤ —Å –¥–∞–Ω–Ω—ã–º–∏
    columns: —Å–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π —Å—Ç–æ–ª–±—Ü–æ–≤
    """
    logger.info("–°–æ–∑–¥–∞–Ω–∏–µ Excel-—Ñ–∞–π–ª–∞ (–æ–¥–∏–Ω –ª–∏—Å—Ç) —Å %d —Å—Ç—Ä–æ–∫(–∞–º–∏)", len(rows))
    try:
        df = pd.DataFrame(rows, columns=columns)
        with tempfile.NamedTemporaryFile(delete=False, suffix=".xlsx") as tmp:
            with pd.ExcelWriter(tmp.name, engine='openpyxl') as writer:
                df.to_excel(writer, index=False, sheet_name='–≠–∫—Å–ø–æ—Ä—Ç')
                worksheet = writer.sheets['–≠–∫—Å–ø–æ—Ä—Ç']
                header_fill = PatternFill(start_color='87CEEB', end_color='87CEEB', fill_type='solid')
                for cell in worksheet[1]:
                    cell.fill = header_fill
                for col in worksheet.columns:
                    max_length = max(len(str(cell.value)) if cell.value else 0 for cell in col)
                    worksheet.column_dimensions[col[0].column_letter].width = max_length + 2
            logger.info("Excel-—Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω: %s", tmp.name)
            return tmp.name
    except Exception as e:
        logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ Excel-—Ñ–∞–π–ª–∞: %s", e, exc_info=True)
        raise

def clean_sheet_name(name):
    clean = re.sub(r'[:\\/?*\[\]]', '_', str(name))[:31]
    logger.debug("–û—á–∏—â–µ–Ω–æ –∏–º—è –ª–∏—Å—Ç–∞: %s -> %s", name, clean)
    return clean

def create_excel_multisheet(data_per_user, columns):
    """
    –ú—É–ª—å—Ç–∏–ª–∏—Å—Ç–æ–≤–æ–π Excel-—Ñ–∞–π–ª –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.
    data_per_user: dict{user_label: [rows]}
    columns: —Å–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π —Å—Ç–æ–ª–±—Ü–æ–≤
    """
    logger.info("–°–æ–∑–¥–∞–Ω–∏–µ –º—É–ª—å—Ç–∏–ª–∏—Å—Ç–æ–≤–æ–≥–æ Excel-—Ñ–∞–π–ª–∞ –¥–ª—è %d –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π", len(data_per_user))
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".xlsx") as tmp:
            with pd.ExcelWriter(tmp.name, engine='openpyxl') as writer:
                for user_label, rows in data_per_user.items():
                    sheet_name = clean_sheet_name(user_label)
                    df = pd.DataFrame(rows, columns=columns)
                    df.to_excel(writer, index=False, sheet_name=sheet_name)
                    worksheet = writer.sheets[sheet_name]
                    header_fill = PatternFill(start_color='87CEEB', end_color='87CEEB', fill_type='solid')
                    for cell in worksheet[1]:
                        cell.fill = header_fill
                    for col in worksheet.columns:
                        max_length = max(len(str(cell.value)) if cell.value else 0 for cell in col)
                        worksheet.column_dimensions[col[0].column_letter].width = max_length + 2
            logger.info("–ú—É–ª—å—Ç–∏–ª–∏—Å—Ç–æ–≤—ã–π Excel-—Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω: %s", tmp.name)
            return tmp.name
    except Exception as e:
        logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –º—É–ª—å—Ç–∏–ª–∏—Å—Ç–æ–≤–æ–≥–æ Excel-—Ñ–∞–π–ª–∞: %s", e, exc_info=True)
        raise

def get_vladivostok_filename(prefix="–°–ª–µ–∂–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤"):
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∏–º—è —Ñ–∞–π–ª–∞ –ø–æ –í–ª–∞–¥–∏–≤–æ—Å—Ç–æ–∫—Å–∫–æ–º—É –≤—Ä–µ–º–µ–Ω–∏ (UTC+10).
    """
    vladivostok_time = datetime.utcnow() + timedelta(hours=10)
    filename = f"{prefix} {vladivostok_time.strftime('%H-%M')}.xlsx"
    logger.debug("–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ –∏–º—è —Ñ–∞–π–ª–∞ –¥–ª—è –í–ª–∞–¥–∏–≤–æ—Å—Ç–æ–∫–∞: %s", filename)
    return filename
</file>

<file path="logger.py">
# logger.py
import logging
from logging.handlers import RotatingFileHandler
import os

LOG_DIR = "logs"
LOG_FILE = "bot.log"
os.makedirs(LOG_DIR, exist_ok=True)

from typing import Optional

def get_logger(name: Optional[str] = None):
    logger = logging.getLogger(name)
    if not logger.hasHandlers():
        formatter = logging.Formatter(
            '%(asctime)s %(levelname)s [%(module)s:%(lineno)d] %(message)s'
        )
        handler = RotatingFileHandler(
            os.path.join(LOG_DIR, LOG_FILE),
            maxBytes=5*1024*1024,  # 5 –ú–ë –Ω–∞ —Ñ–∞–π–ª, –ø–æ—Ç–æ–º –ª–æ–≥ –±—É–¥–µ—Ç —Ä–æ—Ç–∏—Ä–æ–≤–∞—Ç—å—Å—è
            backupCount=5,         # —Ö—Ä–∞–Ω–∏—Ç—å 5 —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤ –ª–æ–≥–æ–≤
            encoding="utf-8"
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ, —á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å –ª–æ–≥–∏ –≤ –∫–æ–Ω—Å–æ–ª–∏ –ø—Ä–∏ –æ—Ç–ª–∞–¥–∫–µ:
        stream = logging.StreamHandler()
        stream.setFormatter(formatter)
        logger.addHandler(stream)
    return logger
</file>

<file path=".github/workflows/deploy.yml">
name: üöÄ Deploy to VDS

on:
  push:
    branches:
      - main  # –∏–ª–∏ master

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.VDS_DEPLOY_KEY }}" > ~/.ssh/id_ed25519
        chmod 600 ~/.ssh/id_ed25519
        ssh-keyscan -H 109.172.30.183 >> ~/.ssh/known_hosts

    - name: Deploy via SSH
      run: |
        ssh -i ~/.ssh/id_ed25519 root@109.172.30.183 << 'EOF'
          cd /opt/bot
          git pull origin main
          source venv/bin/activate
          pip install -r requirements.txt
          supervisorctl restart telegrambot
        EOF
</file>

<file path="handlers/broadcast.py">
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton

from telegram.ext import (
    ContextTypes, ConversationHandler,
    CommandHandler, MessageHandler, CallbackQueryHandler, filters
)
from logger import get_logger

logger = get_logger(__name__)

from config import ADMIN_CHAT_ID
from db import get_all_user_ids

BROADCAST_TEXT, BROADCAST_CONFIRM = range(2)

async def broadcast_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    message = update.message
    if not user or not message:
        return ConversationHandler.END
    if user.id != ADMIN_CHAT_ID:
        await message.reply_text("–ò–∑–≤–∏–Ω–∏, —Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∞.")
        return ConversationHandler.END
    await message.reply_text("–í–≤–µ–¥–∏ —Ç–µ–∫—Å—Ç —Ä–∞—Å—Å—ã–ª–∫–∏ –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:")
    return BROADCAST_TEXT

async def broadcast_get_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message
    if not message:
        return ConversationHandler.END
    text = message.text
    if context.user_data is None:
        context.user_data = {}
    context.user_data['broadcast_text'] = text
    keyboard = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("üöÄ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="confirm_broadcast"),
            InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_broadcast")
        ]
    ])
    await message.reply_text(
        f"–¢–µ–∫—Å—Ç —Ä–∞—Å—Å—ã–ª–∫–∏:\n\n{text}\n\n–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É?",
        reply_markup=keyboard
    )
    return BROADCAST_CONFIRM

async def broadcast_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query:
        return ConversationHandler.END
    await query.answer()
    if query.data == "cancel_broadcast":
        await query.edit_message_text("–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.")
        return ConversationHandler.END

    if context.user_data is None:
        context.user_data = {}
    text = context.user_data.get('broadcast_text', '')
    user_ids = await get_all_user_ids()
    sent_ids = []
    for user_id in set(user_ids):
        try:
            await context.bot.send_message(chat_id=user_id, text=text)
            sent_ids.append(user_id)
        except Exception:
            continue
    await query.edit_message_text(
        f"–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n"
        f"–£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {len(sent_ids)}\n"
        f"user_id: {', '.join(str(uid) for uid in sent_ids)}"
    )
    return ConversationHandler.END

broadcast_conversation_handler = ConversationHandler(
    entry_points=[CommandHandler("broadcast", broadcast_start)],
    states={
        BROADCAST_TEXT: [MessageHandler(filters.TEXT & ~filters.COMMAND, broadcast_get_text)],
        BROADCAST_CONFIRM: [CallbackQueryHandler(broadcast_confirm)],
    },
    fallbacks=[],
)
</file>

<file path=".gitignore">
.env
</file>

<file path="alembic.ini">
# A generic, single database configuration.

[alembic]
# path to migration scripts.
# this is typically a path given in POSIX (e.g. forward slashes)
# format, relative to the token %(here)s which refers to the location of this
# ini file
script_location = %(here)s/migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.  for multiple paths, the path separator
# is defined by "path_separator" below.
prepend_sys_path = .


# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library and tzdata library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to <script_location>/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "path_separator"
# below.
# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions

# path_separator; This indicates what character is used to split lists of file
# paths, including version_locations and prepend_sys_path within configparser
# files such as alembic.ini.
# The default rendered in new alembic.ini files is "os", which uses os.pathsep
# to provide os-dependent path splitting.
#
# Note that in order to support legacy alembic.ini files, this default does NOT
# take place if path_separator is not present in alembic.ini.  If this
# option is omitted entirely, fallback logic is as follows:
#
# 1. Parsing of the version_locations option falls back to using the legacy
#    "version_path_separator" key, which if absent then falls back to the legacy
#    behavior of splitting on spaces and/or commas.
# 2. Parsing of the prepend_sys_path option falls back to the legacy
#    behavior of splitting on spaces, commas, or colons.
#
# Valid values for path_separator are:
#
# path_separator = :
# path_separator = ;
# path_separator = space
# path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
path_separator = os

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

# database URL.  This is consumed by the user-maintained env.py script only.
# other means of configuring database URLs may be customized within the env.py
# file.
sqlalchemy.url = env:DATABASE_URL


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration.  This is also consumed by the user-maintained
# env.py script only.
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="requirements.txt">
python-telegram-bot[webhooks]==22.1
imap-tools
apscheduler
pandas
openpyxl
psycopg2-binary
requests>=2.31.0
python-dotenv
sqlalchemy>=1.4
alembic
asyncpg
</file>

<file path="migrations/versions/03a7f0ead8f9_init.py">
"""init

Revision ID: 03a7f0ead8f9
Revises: 
Create Date: 2025-06-16 00:06:23.670029

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '03a7f0ead8f9'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('stats',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('container_number', sa.String(), nullable=True),
    sa.Column('user_id', sa.BigInteger(), nullable=True),
    sa.Column('username', sa.String(), nullable=True),
    sa.Column('timestamp', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('tracking',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('container_number', sa.String(), nullable=True),
    sa.Column('from_station', sa.String(), nullable=True),
    sa.Column('to_station', sa.String(), nullable=True),
    sa.Column('current_station', sa.String(), nullable=True),
    sa.Column('operation', sa.String(), nullable=True),
    sa.Column('operation_date', sa.String(), nullable=True),
    sa.Column('waybill', sa.String(), nullable=True),
    sa.Column('km_left', sa.Integer(), nullable=True),
    sa.Column('forecast_days', sa.Float(), nullable=True),
    sa.Column('wagon_number', sa.String(), nullable=True),
    sa.Column('operation_road', sa.String(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('tracking_subscriptions',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(), nullable=True),
    sa.Column('containers', sa.ARRAY(sa.String()), nullable=False),
    sa.Column('notify_time', sa.Time(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    
def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('playing_with_neon',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('value', sa.REAL(), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('playing_with_neon_pkey'))
    )
    op.drop_table('tracking_subscriptions')
    op.drop_table('tracking')
    op.drop_table('stats')
    # ### end Alembic commands ###
</file>

<file path="migrations/env.py">
from logging.config import fileConfig
import os
from dotenv import load_dotenv
from sqlalchemy import engine_from_config
from sqlalchemy import pool
from alembic import context

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env
load_dotenv()

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –æ–±—ä–µ–∫—Ç Base –∏–∑ models.py
from models import Base

print(f"üîó Alembic –ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –∫: {os.getenv('ALEMBIC_DATABASE_URL')}")

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Alembic
config = context.config

# –ó–∞–≥—Ä—É–∂–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ DATABASE_URL –∏–∑ .env
config.set_main_option('sqlalchemy.url', os.getenv("ALEMBIC_DATABASE_URL")) # type: ignore

# –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ñ–∞–π–ª –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata

def run_migrations_offline():
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        compare_type=True,  # –ß—Ç–æ–±—ã —É—á–∏—Ç—ã–≤–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ç–∏–ø–æ–≤
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online():
    connectable = engine_from_config(
        config.get_section(config.config_ini_section), # type: ignore
        prefix='sqlalchemy.',
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
            compare_type=True,
        )

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="alembic/env.py">
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context
from dotenv import load_dotenv
import os
from typing import cast

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env
load_dotenv()

# –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
database_url = os.getenv("ALEMBIC_DATABASE_URL") or os.getenv("DATABASE_URL")
if not database_url:
    raise RuntimeError(
        "\n‚ùå DATABASE_URL –Ω–µ –∑–∞–¥–∞–Ω –≤ .env –∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è!\n"
        "–ü—Ä–æ–≤–µ—Ä—å —Ñ–∞–π–ª .env –∏–ª–∏ –∫–æ–º–∞–Ω–¥—É export.\n"
        "–ü—Ä–∏–º–µ—Ä:\n"
        "export DATABASE_URL='postgresql+asyncpg://user:pass@host:port/db?sslmode=require'\n"
    )
database_url = cast(str, database_url)

# –ï—Å–ª–∏ asyncpg ‚Äî –ø–æ–¥–º–µ–Ω—è–µ–º –Ω–∞ psycopg2 –¥–ª—è Alembic
if database_url.startswith("postgresql+asyncpg"):
    alembic_url = database_url.replace("postgresql+asyncpg", "postgresql+psycopg2")
    print("‚ö°Ô∏è Alembic: asyncpg ‚Üí psycopg2 (–¥–ª—è –º–∏–≥—Ä–∞—Ü–∏–π)")
else:
    alembic_url = database_url

# Alembic Config
config = context.config
config.set_main_option('sqlalchemy.url', alembic_url)
print(f"üîó Alembic –ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –∫ –±–∞–∑–µ: {alembic_url.split('@')[-1].split('?')[0]}")  # –Ω–µ —Å–≤–µ—Ç–∏–º –ø–∞—Ä–æ–ª—å

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–π —Å–≤–æ–∏ –º–æ–¥–µ–ª–∏ —Å—é–¥–∞ –¥–ª—è autogenerate
# from src.models import Base
target_metadata = None  # Base.metadata

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    from sqlalchemy import create_engine
    connectable = create_engine(
        alembic_url,
        poolclass=pool.NullPool,
    )
    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )
        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="handlers/admin_handlers.py">
import pandas as pd
from telegram import Update
from telegram.ext import ContextTypes
from config import ADMIN_CHAT_ID
from datetime import datetime, timedelta, time
from sqlalchemy import text
from sqlalchemy.future import select
from db import SessionLocal
from models import TrackingSubscription, Tracking
from logger import get_logger

from utils.send_tracking import create_excel_file, create_excel_multisheet, get_vladivostok_filename

logger = get_logger(__name__)

# /tracking ‚Äî –≤—ã–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö –ø–æ–¥–ø–∏—Å–æ–∫ –Ω–∞ —Å–ª–µ–∂–µ–Ω–∏–µ –≤ Excel
async def tracking(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = user.id if user is not None else None
    logger.info(f"[tracking] –ó–∞–ø—Ä–æ—Å –≤—ã–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö –ø–æ–¥–ø–∏—Å–æ–∫ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
    if user_id != ADMIN_CHAT_ID:
        logger.warning(f"[tracking] –û—Ç–∫–∞–∑ –≤ –¥–æ—Å—Ç—É–ø–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}")
        if update.message:
            await update.message.reply_text("‚õî –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        elif update.effective_chat:
            await update.effective_chat.send_message("‚õî –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return

    try:
        async with SessionLocal() as session:
            result = await session.execute(text("SELECT * FROM tracking_subscriptions"))
            subs = result.fetchall()
            if not subs:
                logger.info("[tracking] –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–ª–µ–∂–µ–Ω–∏–π –¥–ª—è –≤—ã–≥—Ä—É–∑–∫–∏.")
                if update.message:
                    await update.message.reply_text("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–ª–µ–∂–µ–Ω–∏–π.")
                elif update.effective_chat:
                    await update.effective_chat.send_message("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–ª–µ–∂–µ–Ω–∏–π.")
                return

            columns = result.keys()
            data = [dict(zip(columns, row)) for row in subs]
            df = pd.DataFrame(data)
            file_path = create_excel_file(df.values.tolist(), list(df.columns))
            filename = get_vladivostok_filename().replace("–î–∏—Å–ª–æ–∫–∞—Ü–∏—è", "tracking_subs")
            with open(file_path, "rb") as f:
                if update.message:
                    await update.message.reply_document(document=f, filename=filename)
                elif update.effective_chat:
                    await update.effective_chat.send_document(document=f, filename=filename)
            logger.info(f"[tracking] –í—ã–≥—Ä—É–∑–∫–∞ –ø–æ–¥–ø–∏—Å–æ–∫ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
    except Exception as e:
        logger.error(f"[tracking] –û—à–∏–±–∫–∞ –≤—ã–≥—Ä—É–∑–∫–∏ –ø–æ–¥–ø–∏—Å–æ–∫: {e}", exc_info=True)
        if update.message:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –ø–æ–¥–ø–∏—Å–æ–∫.")
        elif update.effective_chat:
            await update.effective_chat.send_message("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –ø–æ–¥–ø–∏—Å–æ–∫.")

# /stats ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å—É—Ç–∫–∏ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º –≤–∏–¥–µ
async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = user.id if user is not None else None
    logger.info(f"[stats] –ó–∞–ø—Ä–æ—Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∑–∞ —Å—É—Ç–∫–∏ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
    if user_id != ADMIN_CHAT_ID:
        logger.warning(f"[stats] –û—Ç–∫–∞–∑ –≤ –¥–æ—Å—Ç—É–ø–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}")
        if update.message:
            await update.message.reply_text("‚õî –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        elif update.effective_chat:
            await update.effective_chat.send_message("‚õî –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return

    try:
        async with SessionLocal() as session:
            query = text("""
                SELECT user_id, COALESCE(username, '‚Äî') AS username, COUNT(*) AS –∑–∞–ø—Ä–æ—Å–æ–≤,
                    STRING_AGG(DISTINCT container_number, ', ') AS –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã
                FROM stats
                WHERE timestamp >= NOW() - INTERVAL '1 day'
                    AND user_id != :admin_id
                GROUP BY user_id, username
                ORDER BY –∑–∞–ø—Ä–æ—Å–æ–≤ DESC
            """)
            result = await session.execute(query, {'admin_id': ADMIN_CHAT_ID})
            rows = result.fetchall()

        if not rows:
            logger.info("[stats] –ù–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å—É—Ç–∫–∏.")
            if update.message:
                await update.message.reply_text("–ù–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å—É—Ç–∫–∏.")
            elif update.effective_chat:
                await update.effective_chat.send_message("–ù–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å—É—Ç–∫–∏.")
            return

        text_msg = "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞:\n\n"
        messages = []
        for row in rows:
            entry = (
                f"üë§ {row.username} (ID: {row.user_id})\n"
                f"–ó–∞–ø—Ä–æ—Å–æ–≤: {row.–∑–∞–ø—Ä–æ—Å–æ–≤}\n"
                f"–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã: {row.–∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã}\n\n"
            )
            if len(text_msg) + len(entry) > 4000:
                messages.append(text_msg)
                text_msg = ""
            text_msg += entry
        messages.append(text_msg)
        for msg in messages:
            if update.message:
                await update.message.reply_text(msg)
            elif update.effective_chat:
                await update.effective_chat.send_message(msg)
        logger.info("[stats] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
    except Exception as e:
        logger.error(f"[stats] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}", exc_info=True)
        if update.message:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.")
        elif update.effective_chat:
            await update.effective_chat.send_message("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.")

# /exportstats ‚Äî Excel –≤—ã–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è (–∫—Ä–æ–º–µ –∞–¥–º–∏–Ω–∞)
async def exportstats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = user.id if user is not None else None
    logger.info(f"[exportstats] –ó–∞–ø—Ä–æ—Å Excel-–≤—ã–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
    if user_id != ADMIN_CHAT_ID:
        logger.warning(f"[exportstats] –û—Ç–∫–∞–∑ –≤ –¥–æ—Å—Ç—É–ø–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}")
        if update.message:
            await update.message.reply_text("‚õî –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        elif update.effective_chat:
            await update.effective_chat.send_message("‚õî –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return

    try:
        async with SessionLocal() as session:
            query = text("SELECT * FROM stats WHERE user_id != :admin_id")
            result = await session.execute(query, {'admin_id': ADMIN_CHAT_ID})
            rows = result.fetchall()

        if not rows:
            logger.info("[exportstats] –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞.")
            if update.message:
                await update.message.reply_text("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞.")
            elif update.effective_chat:
                await update.effective_chat.send_message("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞.")
            return

        columns = list(result.keys())
        df = pd.DataFrame(rows, columns=columns)
        file_path = create_excel_file(df.values.tolist(), list(df.columns))
        filename = get_vladivostok_filename().replace("–î–∏—Å–ª–æ–∫–∞—Ü–∏—è", "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
        with open(file_path, "rb") as f:
            if update.message:
                await update.message.reply_document(document=f, filename=filename)
            elif update.effective_chat:
                await update.effective_chat.send_document(document=f, filename=filename)
        logger.info(f"[exportstats] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤ Excel —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
    except Exception as e:
        logger.error(f"[exportstats] –û—à–∏–±–∫–∞ –≤—ã–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}", exc_info=True)
        if update.message:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.")
        elif update.effective_chat:
            await update.effective_chat.send_message("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.")

# /testnotify ‚Äî –æ–¥–∏–Ω Excel, –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏, –∫–∞–∂–¥—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–¥–µ–ª—å–Ω—ã–º –ª–∏—Å—Ç–æ–º
async def test_notify(update, context):
    user = update.effective_user
    user_id = user.id if user is not None else None
    logger.info(f"[test_notify] –ó–∞–ø—Ä–æ—Å —Ç–µ—Å—Ç–æ–≤–æ–π –º—É–ª—å—Ç–∏-—Ä–∞—Å—Å—ã–ª–∫–∏ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
    if user_id != ADMIN_CHAT_ID:
        logger.warning(f"[test_notify] –û—Ç–∫–∞–∑ –≤ –¥–æ—Å—Ç—É–ø–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}")
        await update.message.reply_text("‚õî –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return

    try:
        async with SessionLocal() as session:
            result = await session.execute(select(TrackingSubscription))
            subscriptions = result.scalars().all()

            columns = [
                '–ù–æ–º–µ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞', '–°—Ç–∞–Ω—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è', '–°—Ç–∞–Ω—Ü–∏—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è',
                '–°—Ç–∞–Ω—Ü–∏—è –æ–ø–µ—Ä–∞—Ü–∏–∏', '–û–ø–µ—Ä–∞—Ü–∏—è', '–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è –æ–ø–µ—Ä–∞—Ü–∏–∏',
                '–ù–æ–º–µ—Ä –Ω–∞–∫–ª–∞–¥–Ω–æ–π', '–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Å—Ç–∞–≤—à–µ–µ—Å—è', '–ü—Ä–æ–≥–Ω–æ–∑ –ø—Ä–∏–±—ã—Ç–∏—è (–¥–Ω–µ–π)',
                '–ù–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞', '–î–æ—Ä–æ–≥–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏'
            ]
            data_per_user = {}

            for sub in subscriptions:
                user_label = f"{sub.username or sub.user_id} (id:{sub.user_id})"
                rows = []
                for container in sub.containers:
                    res = await session.execute(
                        select(Tracking).filter(Tracking.container_number == container).order_by(Tracking.operation_date.desc())
                    )
                    track = res.scalars().first()
                    if track:
                        rows.append([
                            track.container_number,
                            track.from_station,
                            track.to_station,
                            track.current_station,
                            track.operation,
                            track.operation_date,
                            track.waybill,
                            track.km_left,
                            track.forecast_days,
                            track.wagon_number,
                            track.operation_road
                        ])
                data_per_user[user_label] = rows if rows else [["–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö"] + [""] * (len(columns)-1)]

            file_path = create_excel_multisheet(data_per_user, columns)
            filename = get_vladivostok_filename("–¢–µ—Å—Ç–æ–≤–∞—è –¥–∏—Å–ª–æ–∫–∞—Ü–∏—è")
            with open(file_path, "rb") as f:
                await update.message.reply_document(
                    document=f,
                    filename=filename,
                    caption="–¢–µ—Å—Ç–æ–≤–∞—è –¥–∏—Å–ª–æ–∫–∞—Ü–∏—è –ø–æ –≤—Å–µ–º –ø–æ–¥–ø–∏—Å—á–∏–∫–∞–º (—Ä–∞–∑–¥–µ–ª–µ–Ω–æ –ø–æ –ª–∏—Å—Ç–∞–º)"
                )
            await update.message.reply_text("‚úÖ –¢–µ—Å—Ç–æ–≤–∞—è –º—É–ª—å—Ç–∏-—Ä–∞—Å—Å—ã–ª–∫–∞ –≥–æ—Ç–æ–≤–∞ –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ–¥–Ω–∏–º —Ñ–∞–π–ª–æ–º.")
            logger.info("[test_notify] –¢–µ—Å—Ç–æ–≤–∞—è –º—É–ª—å—Ç–∏-—Ä–∞—Å—Å—ã–ª–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.")
    except Exception as e:
        logger.error(f"[test_notify] –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–π –º—É–ª—å—Ç–∏-—Ä–∞—Å—Å—ã–ª–∫–∏: {e}", exc_info=True)
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç–µ—Å—Ç–æ–≤–æ–π —Ä–∞—Å—Å—ã–ª–∫–µ.")
</file>

<file path="config.py">
from dotenv import load_dotenv
import os

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL")
TOKEN = os.getenv("TELEGRAM_TOKEN")
ADMIN_CHAT_ID = int(os.getenv("ADMIN_CHAT_ID")) # type: ignore
RENDER_HOSTNAME = os.getenv("RENDER_EXTERNAL_HOSTNAME")
PORT = int(os.environ.get("PORT", 10000))
</file>

<file path="handlers/tracking_handlers.py">
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ContextTypes, CallbackQueryHandler, MessageHandler, filters, ConversationHandler
)
from db import SessionLocal
from sqlalchemy import delete, select
from models import TrackingSubscription
import datetime
from utils.keyboards import cancel_tracking_confirm_keyboard
from logger import get_logger

logger = get_logger(__name__)

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler
TRACK_CONTAINERS, SET_TIME = range(2)

# 1. –ó–∞–ø—Ä–æ—Å–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤
async def ask_containers(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = user.id if user is not None else "Unknown"
    logger.info(f"[ask_containers] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –Ω–∞—á–∞–ª –ø–æ—Å—Ç–∞–Ω–æ–≤–∫—É –Ω–∞ —Å–ª–µ–∂–µ–Ω–∏–µ.")
    if update.callback_query:
        await update.callback_query.answer()
        if update.callback_query.message is not None:
            if update.effective_chat is not None:
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text="–í–≤–µ–¥–∏—Ç–µ —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ –¥–ª—è —Å–ª–µ–∂–µ–Ω–∏—è (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):"
                )
            else:
                logger.warning("[ask_containers] effective_chat is None, cannot send message.")
        else:
            logger.warning("[ask_containers] callback_query.message is None, cannot send reply_text.")
    else:
        if update.message is not None:
            await update.message.reply_text(
                "–í–≤–µ–¥–∏—Ç–µ —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ –¥–ª—è —Å–ª–µ–∂–µ–Ω–∏—è (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):"
            )
        else:
            logger.warning("[ask_containers] update.message is None, cannot send reply_text.")
    return TRACK_CONTAINERS

# 2. –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
async def receive_containers(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.text:
        user_id = update.effective_user.id if update.effective_user is not None else "Unknown"
        logger.warning(f"[receive_containers] –ù–µ—Ç —Ç–µ–∫—Å—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
        if update.message is not None:
            await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é.")
        return TRACK_CONTAINERS
    containers = [c.strip().upper() for c in update.message.text.split(',') if c.strip()]
    if not containers:
        user_id = update.effective_user.id if update.effective_user is not None else "Unknown"
        logger.warning(f"[receive_containers] –ü—É—Å—Ç–æ–π –≤–≤–æ–¥ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
        await update.message.reply_text("–°–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ –ø—É—Å—Ç. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤–≤–æ–¥:")
        return TRACK_CONTAINERS

    user_id = update.effective_user.id if update.effective_user is not None else "Unknown"
    logger.info(f"[receive_containers] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –≤—ã–±—Ä–∞–ª –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã: {containers}")
    if context.user_data is None:
        context.user_data = {}
    context.user_data['containers'] = containers

    keyboard = [
        [InlineKeyboardButton("09:00", callback_data="time_09")],
        [InlineKeyboardButton("16:00", callback_data="time_16")]
    ]
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return SET_TIME

# 3. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Ä–µ–º—è —Ä–∞—Å—Å—ã–ª–∫–∏ –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É –≤ –ë–î
async def set_tracking_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.callback_query is not None and update.callback_query.data is not None:
        await update.callback_query.answer()
        time_choice = update.callback_query.data.split("_")[1]
    else:
        logger.warning("[set_tracking_time] update.callback_query is None or data is None, cannot answer or get data.")
        return ConversationHandler.END
    time_obj = datetime.time(hour=9) if time_choice == "09" else datetime.time(hour=16)

    if context.user_data is None:
        context.user_data = {}
    containers = context.user_data.get('containers', [])
    user_id = update.effective_user.id if update.effective_user is not None else "Unknown"
    username = update.effective_user.username if update.effective_user is not None else "Unknown"

    logger.info(f"[set_tracking_time] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} ({username}) —Å—Ç–∞–≤–∏—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã {containers} –Ω–∞ {time_obj.strftime('%H:%M')}")

    try:
        async with SessionLocal() as session:
            sub = TrackingSubscription(
                user_id=user_id,
                username=username,
                containers=containers,  # ARRAY –≤ Postgres
                notify_time=time_obj
            )
            session.add(sub)
            await session.commit()
        logger.info(f"[set_tracking_time] –ü–æ–¥–ø–∏—Å–∫–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –Ω–∞ {time_obj.strftime('%H:%M')}")
        if update.effective_chat is not None:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=f"‚úÖ –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã {', '.join(containers)} –ø–æ—Å—Ç–∞–≤–ª–µ–Ω—ã –Ω–∞ —Å–ª–µ–∂–µ–Ω–∏–µ –≤ {time_obj.strftime('%H:%M')} (–ø–æ –º–µ—Å—Ç–Ω–æ–º—É –≤—Ä–µ–º–µ–Ω–∏)"
            )
        else:
            logger.warning("[set_tracking_time] effective_chat is None, cannot send confirmation message.")
        return ConversationHandler.END
    except Exception as e:
        logger.error(f"[set_tracking_time] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}", exc_info=True)
        await update.callback_query.edit_message_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        return ConversationHandler.END

# 4. –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–º–µ–Ω—ã –≤–Ω—É—Ç—Ä–∏ ConversationHandler
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id if update.effective_user is not None else "Unknown"
    logger.info(f"[cancel] –û—Ç–º–µ–Ω–∞ —Å–ª–µ–∂–µ–Ω–∏—è –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
    if update.message is not None:
        await update.message.reply_text("‚ùå –û—Ç–º–µ–Ω–∞ —Å–ª–µ–∂–µ–Ω–∏—è")
    else:
        logger.warning("[cancel] update.message is None, cannot send reply_text.")
    return ConversationHandler.END

# 5. –°—Ç–∞—Ä—Ç –æ—Ç–º–µ–Ω—ã —Å–ª–µ–∂–µ–Ω–∏—è (–∫–Ω–æ–ø–∫–∞)
async def cancel_tracking_start(update, context):
    logger.info(f"[cancel_tracking_start] –ó–∞–ø—Ä–æ—à–µ–Ω–∞ –æ—Ç–º–µ–Ω–∞ —Å–ª–µ–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º {update.effective_user.id}")
    await update.message.reply_text(
        "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–º–µ–Ω–∏—Ç—å –≤—Å–µ –≤–∞—à–∏ —Å–ª–µ–∂–µ–Ω–∏—è?",
        reply_markup=cancel_tracking_confirm_keyboard
    )

# 6. Callback –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è/–æ—Ç–º–µ–Ω—ã
async def cancel_tracking_confirm(update, context):
    query = update.callback_query
    user_id = query.from_user.id

    if query.data == "cancel_tracking_yes":
        try:
            async with SessionLocal() as session:
                await session.execute(
                    delete(TrackingSubscription).where(TrackingSubscription.user_id == user_id)
                )
                await session.commit()
            await query.edit_message_text("‚ùå –í—Å–µ –≤–∞—à–∏ —Å–ª–µ–∂–µ–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω—ã.")
            logger.info(f"[cancel_tracking_confirm] –í—Å–µ —Å–ª–µ–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} —É–¥–∞–ª–µ–Ω—ã.")
        except Exception as e:
            logger.error(f"[cancel_tracking_confirm] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ —Å–ª–µ–∂–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}", exc_info=True)
            await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ —Å–ª–µ–∂–µ–Ω–∏–π.")
    elif query.data == "cancel_tracking_no":
        logger.info(f"[cancel_tracking_confirm] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –æ—Ç–º–µ–Ω–∏–ª –æ—Ç–º–µ–Ω—É —Å–ª–µ–∂–µ–Ω–∏–π.")
        await query.edit_message_text("–û—Ç–º–µ–Ω–∞ —Å–ª–µ–∂–µ–Ω–∏—è –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞.")

# –°—Ç–∞—Ä—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –¥–ª—è –∫–æ–º–∞–Ω–¥—ã /canceltracking
async def cancel_tracking(update, context):
    user_id = update.effective_user.id if update.effective_user is not None else "Unknown"
    try:
        async with SessionLocal() as session:
            await session.execute(
                delete(TrackingSubscription).where(TrackingSubscription.user_id == user_id)
            )
            await session.commit()
        await update.message.reply_text("‚ùå –í—Å–µ –≤–∞—à–∏ —Å–ª–µ–∂–µ–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω—ã.")
        logger.info(f"[cancel_tracking] –í—Å–µ —Å–ª–µ–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} —É–¥–∞–ª–µ–Ω—ã.")
    except Exception as e:
        logger.error(f"[cancel_tracking] –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–ª–µ–∂–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}", exc_info=True)
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ —Å–ª–µ–∂–µ–Ω–∏–π.")

# ConversationHandler –¥–ª—è –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é
def tracking_conversation_handler():
    return ConversationHandler(
        entry_points=[
            CallbackQueryHandler(ask_containers, pattern="^track_request$"),
            MessageHandler(filters.Regex("^üîî –ó–∞–¥–∞—Ç—å —Å–ª–µ–∂–µ–Ω–∏–µ$"), ask_containers),  # –¥–æ–±–∞–≤—å —ç—Ç–æ—Ç
        ],
        states={
            TRACK_CONTAINERS: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_containers)],
            SET_TIME: [CallbackQueryHandler(set_tracking_time, pattern="^time_")]
        },
        fallbacks=[MessageHandler(filters.COMMAND, cancel)],
    )
</file>

<file path="scheduler.py">
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from sqlalchemy.future import select
from datetime import time
from db import SessionLocal
from models import TrackingSubscription, Tracking
from utils.send_tracking import create_excel_file, get_vladivostok_filename
from mail_reader import check_mail
from logger import get_logger

logger = get_logger(__name__)

scheduler = AsyncIOScheduler()

def start_scheduler(bot):
    scheduler.add_job(send_notifications, 'cron', hour=23, minute=0, args=[bot, time(9, 0)])
    scheduler.add_job(send_notifications, 'cron', hour=6, minute=0, args=[bot, time(16, 0)])
    scheduler.add_job(check_mail, 'cron', minute=20)  # –∑–∞–ø—É—Å–∫ –∫–∞–∂–¥—ã–π —á–∞—Å –≤ 20 –º–∏–Ω—É—Ç 
    logger.info("üïì –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫: –∑–∞–¥–∞—á–∏ –¥–æ–±–∞–≤–ª–µ–Ω—ã.")
    scheduler.start()
    logger.info("üü¢ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–ø—É—â–µ–Ω.")

async def send_notifications(bot, target_time: time):
    logger.info(f"üîî –°—Ç–∞—Ä—Ç —Ä–∞—Å—Å—ã–ª–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è –≤—Ä–µ–º–µ–Ω–∏: {target_time}")
    try:
        async with SessionLocal() as session:
            result = await session.execute(
                select(TrackingSubscription).where(TrackingSubscription.notify_time == target_time)
            )
            subscriptions = result.scalars().all()
            logger.info(f"–ù–∞–π–¥–µ–Ω–æ –ø–æ–¥–ø–∏—Å–æ–∫ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {len(subscriptions)}")
            columns = [
                '–ù–æ–º–µ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞', '–°—Ç–∞–Ω—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è', '–°—Ç–∞–Ω—Ü–∏—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è',
                '–°—Ç–∞–Ω—Ü–∏—è –æ–ø–µ—Ä–∞—Ü–∏–∏', '–û–ø–µ—Ä–∞—Ü–∏—è', '–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è –æ–ø–µ—Ä–∞—Ü–∏–∏',
                '–ù–æ–º–µ—Ä –Ω–∞–∫–ª–∞–¥–Ω–æ–π', '–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Å—Ç–∞–≤—à–µ–µ—Å—è', '–ü—Ä–æ–≥–Ω–æ–∑ –ø—Ä–∏–±—ã—Ç–∏—è (–¥–Ω–µ–π)',
                '–ù–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞', '–î–æ—Ä–æ–≥–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏'
            ]
            for sub in subscriptions:
                rows = []
                for container in sub.containers:
                    res = await session.execute(
                        select(Tracking).filter(Tracking.container_number == container).order_by(Tracking.operation_date.desc())
                    )
                    track = res.scalars().first()
                    if track:
                        rows.append([
                            track.container_number,
                            track.from_station,
                            track.to_station,
                            track.current_station,
                            track.operation,
                            track.operation_date,
                            track.waybill,
                            track.km_left,
                            track.forecast_days,
                            track.wagon_number,
                            track.operation_road
                        ])
                if not rows:
                    containers_list = list(sub.containers) if isinstance(sub.containers, (list, tuple, set)) else []
                    await bot.send_message(sub.user_id, f"üì≠ –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞–º {', '.join(containers_list)}")
                    logger.info(f"–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {sub.user_id} ({containers_list})")
                    continue
                file_path = create_excel_file(rows, columns)
                filename = get_vladivostok_filename()
                try:
                    with open(file_path, "rb") as f:
                        await bot.send_document(
                            chat_id=sub.user_id,
                            document=f,
                            filename=filename
                        )
                    logger.info(f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω —Ñ–∞–π–ª {filename} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {sub.user_id}")
                except Exception as send_err:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {sub.user_id}: {send_err}", exc_info=True)
    except Exception as e:
        logger.critical(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—Å—ã–ª–∫–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}", exc_info=True)
</file>

<file path="handlers/user_handlers.py">
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import ContextTypes, ConversationHandler
from telegram.error import BadRequest
from utils.keyboards import (
    reply_keyboard,
    dislocation_inline_keyboard,
    tracking_inline_keyboard,
    main_menu_keyboard
)
import re
from models import Tracking, Stats
from db import (
    SessionLocal,
    get_all_user_ids,
    get_tracked_containers_by_user,
    remove_user_tracking,
    set_user_email,
)
from sqlalchemy import select
from logger import get_logger

logger = get_logger(__name__)

# –°—Ç–µ–π—Ç—ã –¥–ª—è ConversationHandler
SET_EMAIL = range(1)

COLUMNS = [
    '–ù–æ–º–µ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞', '–°—Ç–∞–Ω—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è', '–°—Ç–∞–Ω—Ü–∏—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è',
    '–°—Ç–∞–Ω—Ü–∏—è –æ–ø–µ—Ä–∞—Ü–∏–∏', '–û–ø–µ—Ä–∞—Ü–∏—è', '–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è –æ–ø–µ—Ä–∞—Ü–∏–∏',
    '–ù–æ–º–µ—Ä –Ω–∞–∫–ª–∞–¥–Ω–æ–π', '–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Å—Ç–∞–≤—à–µ–µ—Å—è', '–ü—Ä–æ–≥–Ω–æ–∑ –ø—Ä–∏–±—ã—Ç–∏—è (–¥–Ω–µ–π)',
    '–ù–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞', '–î–æ—Ä–æ–≥–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏'
]

# --- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    reply_keyboard = [
        ["üì¶ –î–∏—Å–ª–æ–∫–∞—Ü–∏—è", "üîî –ó–∞–¥–∞—Ç—å —Å–ª–µ–∂–µ–Ω–∏–µ"],
        ["‚ùå –û—Ç–º–µ–Ω–∞ —Å–ª–µ–∂–µ–Ω–∏—è"]
    ]
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ üö¢\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –≤ –º–µ–Ω—é:",
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True),
    )

async def show_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await start(update, context)

# --- Email Conversation ---
async def set_email_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à email –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π, –∏–ª–∏ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
        reply_markup=ReplyKeyboardRemove()
    )
    return SET_EMAIL

async def process_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    email = update.message.text
    telegram_id = update.message.from_user.id
    username = update.message.from_user.username or ""

    await set_user_email(telegram_id, username, email)
    await update.message.reply_text(
        f"Email {email} —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω—ë–Ω ‚úÖ", reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END

async def cancel_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–í–≤–æ–¥ email –æ—Ç–º–µ–Ω—ë–Ω.", reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END

# --- –û–±—Ä–∞–±–æ—Ç–∫–∞ reply-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---
async def reply_keyboard_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    if text == "üì¶ –î–∏—Å–ª–æ–∫–∞—Ü–∏—è":
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞:")
    # –ù–ï –≤—ã–∑—ã–≤–∞–µ–º ask_containers –≤—Ä—É—á–Ω—É—é!
    elif text == "üîî –ó–∞–¥–∞—Ç—å —Å–ª–µ–∂–µ–Ω–∏–µ":
        # ConversationHandler —Å–∞–º –æ—Ç—Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–µ –Ω—É–∂–µ–Ω –≤—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏!
        return
    elif text == "‚ùå –û—Ç–º–µ–Ω–∞ —Å–ª–µ–∂–µ–Ω–∏—è":
        from handlers.tracking_handlers import cancel_tracking_start
        return await cancel_tracking_start(update, context)
    else:
        await update.message.reply_text("–ö–æ–º–∞–Ω–¥–∞ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é.")

# --- Inline –∫–Ω–æ–ø–∫–∏ ---
async def menu_button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if query.data == "start":
        await start(query, context)
    elif query.data == "dislocation":
        await query.edit_message_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞:")
    elif query.data == "track_request":
        await query.edit_message_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –¥–ª—è —Å–ª–µ–∂–µ–Ω–∏—è:")

async def dislocation_inline_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞:")

# --- –°—Ç–∏–∫–µ—Ä—ã ---
async def handle_sticker(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sticker = update.message.sticker
    logger.info(f"handle_sticker: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {update.effective_user.id} –ø—Ä–∏—Å–ª–∞–ª —Å—Ç–∏–∫–µ—Ä {sticker.file_id}")
    await update.message.reply_text(f"üÜî ID —ç—Ç–æ–≥–æ —Å—Ç–∏–∫–µ—Ä–∞:\n`{sticker.file_id}`", parse_mode='Markdown')
    await show_menu(update, context)

# --- –ì–ª–∞–≤–Ω–∞—è —Ä–∞–±–æ—á–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–∏—Å–∫–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ ---
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = user.id if user else "‚Äî"
    user_name = user.username if user else "‚Äî"
    logger.info(f"handle_message: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} ({user_name}) –æ—Ç–ø—Ä–∞–≤–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ")
    if not update.message or not update.message.text:
        logger.warning(f"handle_message: –ø—É—Å—Ç–æ–π –≤–≤–æ–¥ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
        await update.message.reply_text("‚õî –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å —Ç–µ–∫—Å—Ç–æ–≤—ã–π –Ω–æ–º–µ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞.")
        await show_menu(update, context)
        return

    user_input = update.message.text
    logger.info(f"–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–≤–æ–¥: {user_input}")
    container_numbers = [c.strip().upper() for c in re.split(r'[\s,\n.]+' , user_input.strip()) if c]
    found_rows = []
    not_found = []

    async with SessionLocal() as session:
        for container_number in container_numbers:
            result = await session.execute(
                select(
                    Tracking.container_number,
                    Tracking.from_station,
                    Tracking.to_station,
                    Tracking.current_station,
                    Tracking.operation,
                    Tracking.operation_date,
                    Tracking.waybill,
                    Tracking.km_left,
                    Tracking.forecast_days,
                    Tracking.wagon_number,
                    Tracking.operation_road
                ).where(
                    Tracking.container_number == container_number
                ).order_by(
                    Tracking.operation_date.desc()
                )
            )
            results = result.fetchall()

            stats_record = Stats(
                container_number=container_number,
                user_id=update.message.from_user.id,
                username=update.message.from_user.username
            )
            session.add(stats_record)
            await session.commit()

            if not results:
                not_found.append(container_number)
                logger.info(f"–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω: {container_number}")
                continue

            row = results[0]
            found_rows.append(list(row))
            logger.info(f"–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –Ω–∞–π–¥–µ–Ω: {container_number}")

    # –ù–µ—Å–∫–æ–ª—å–∫–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ ‚Äî Excel —Ñ–∞–π–ª
    if len(container_numbers) > 1 and found_rows:
        from utils.send_tracking import create_excel_file, get_vladivostok_filename

        file_path = create_excel_file(found_rows, COLUMNS)
        filename = get_vladivostok_filename()
        try:
            with open(file_path, "rb") as f:
                await update.message.reply_document(document=f, filename=filename)
            logger.info(f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω Excel —Å –¥–∏—Å–ª–æ–∫–∞—Ü–∏–µ–π –ø–æ {len(found_rows)} –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ Excel –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}", exc_info=True)

        if not_found:
            await update.message.reply_text("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω—ã: " + ", ".join(not_found))
        await show_menu(update, context)
        return

    # –û–¥–∏–Ω –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä ‚Äî –∫—Ä–∞—Å–∏–≤–æ –æ—Ñ–æ—Ä–º–∏—Ç—å
    elif found_rows:
        row = found_rows[0]
        wagon_number = str(row[9]) if row[9] else "‚Äî"
        wagon_type = "–ø–æ–ª—É–≤–∞–≥–æ–Ω" if wagon_number.startswith("6") else "–ø–ª–∞—Ç—Ñ–æ—Ä–º–∞"

        try:
            km_left = float(row[7])
            forecast_days_calc = round(km_left / 600 + 1, 1)
        except Exception:
            km_left = "‚Äî"
            forecast_days_calc = "‚Äî"

        operation_station = f"{row[3]} üõ§Ô∏è ({row[10]})" if row[10] else row[3]

        msg = (
            f"üì¶ <b>–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä</b>: <code>{row[0]}</code>\n\n"
            f"üõ§ <b>–ú–∞—Ä—à—Ä—É—Ç</b>:\n"
            f"<b>{row[1]}</b> üöÇ ‚Üí <b>{row[2]}</b>\n\n"
            f"üìç <b>–¢–µ–∫—É—â–∞—è —Å—Ç–∞–Ω—Ü–∏—è</b>: {operation_station}\n"
            f"üìÖ <b>–ü–æ—Å–ª–µ–¥–Ω—è—è –æ–ø–µ—Ä–∞—Ü–∏—è</b>:\n"
            f"{row[5]} ‚Äî <i>{row[4]}</i>\n\n"
            f"üöÜ <b>–í–∞–≥–æ–Ω</b>: <code>{wagon_number}</code> ({wagon_type})\n"
            f"üìè <b>–û—Å—Ç–∞–ª–æ—Å—å –µ—Ö–∞—Ç—å</b>: <b>{km_left}</b> –∫–º\n\n"
            f"‚è≥ <b>–û—Ü–µ–Ω–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –≤ –ø—É—Ç–∏</b>:\n"
            f"~<b>{forecast_days_calc}</b> —Å—É—Ç–æ–∫ "
            f"(—Ä–∞—Å—á–µ—Ç: {km_left} –∫–º / 600 –∫–º/—Å—É—Ç–∫–∏ + 1 –¥–µ–Ω—å)"
        )

        await update.message.reply_text(msg, parse_mode="HTML")
        logger.info(f"–î–∏—Å–ª–æ–∫–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ {row[0]} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}")
        await show_menu(update, context)
    else:
        logger.info(f"–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ –≤–≤–µ–¥—ë–Ω–Ω—ã–º –Ω–æ–º–µ—Ä–∞–º –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
        await update.message.reply_text("–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ –≤–≤–µ–¥—ë–Ω–Ω—ã–º –Ω–æ–º–µ—Ä–∞–º.")
        await show_menu(update, context)

# --- –ü–æ–∫–∞–∑–∞—Ç—å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ---
async def show_my_tracking(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    containers = await get_tracked_containers_by_user(user_id)
    if containers:
        msg = "–í—ã –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã:\n" + "\n".join(containers)
    else:
        msg = "–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫ –Ω–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã."
    await update.message.reply_text(msg)

# --- –û—Ç–º–µ–Ω–∞ –≤—Å–µ—Ö –ø–æ–¥–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ---
async def cancel_my_tracking(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    await remove_user_tracking(user_id)
    await update.message.reply_text("–í—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ —É—Å–ø–µ—à–Ω–æ –æ—Ç–º–µ–Ω–µ–Ω—ã.")
</file>

<file path="models.py">
from sqlalchemy import Boolean, Column, Integer, String, BigInteger, DateTime, Float, Time, ARRAY
from sqlalchemy.orm import declarative_base
from sqlalchemy.sql import func

from logger import get_logger

logger = get_logger(__name__)

try:
    Base = declarative_base()

    class TrackingSubscription(Base):
        __tablename__ = "tracking_subscriptions"

        id = Column(Integer, primary_key=True)
        user_id = Column(Integer, nullable=False)
        username = Column(String, nullable=True)
        containers = Column(ARRAY(String), nullable=False)
        notify_time = Column(Time, nullable=False)

    class Stats(Base):
        __tablename__ = 'stats'

        id = Column(Integer, primary_key=True)
        container_number = Column(String)
        user_id = Column(BigInteger)
        username = Column(String)
        timestamp = Column(DateTime, default=func.now())

    class Tracking(Base):
        __tablename__ = 'tracking'

        id = Column(Integer, primary_key=True)
        container_number = Column(String)
        from_station = Column(String)
        to_station = Column(String)
        current_station = Column(String)
        operation = Column(String)
        operation_date = Column(String)
        waybill = Column(String)
        km_left = Column(Integer)
        forecast_days = Column(Float)
        wagon_number = Column(String)
        operation_road = Column(String)

    class User(Base):
        __tablename__ = "users"
        id = Column(Integer, primary_key=True)
        telegram_id = Column(BigInteger, unique=True, nullable=False)
        username = Column(String, nullable=True)
        email = Column(String, nullable=True)
        email_enabled = Column(Boolean, default=False)
        # –¥–∞–ª–µ–µ –º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å profile fields    

    logger.info("–ú–æ–¥–µ–ª–∏ –ë–î —É—Å–ø–µ—à–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –∏ –≥–æ—Ç–æ–≤—ã –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é.")

except Exception as e:
    logger.critical(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–æ–¥–µ–ª–µ–π: {e}", exc_info=True)
</file>

<file path="README.md">
# Telegram Bot Container Tracker

–≠—Ç–æ—Ç –ø—Ä–æ–µ–∫—Ç ‚Äî Telegram-–±–æ—Ç –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö, —Ä–∞–±–æ—Ç—ã —Å –ø–æ—á—Ç–æ–π, –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ –∑–∞–¥–∞—á –∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å PostgreSQL.

## –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏

- –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ —á–µ—Ä–µ–∑ Telegram-–±–æ—Ç–∞
- –ï–∂–µ–¥–Ω–µ–≤–Ω–æ–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–∑—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ (—á–µ—Ä–µ–∑ APScheduler)
- –ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –∏–∑ –ø–æ—á—Ç—ã (IMAP, imap-tools)
- –≠–∫—Å–ø–æ—Ä—Ç –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ Excel (openpyxl, pandas)
- –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö (SQLAlchemy, asyncpg)
- –ú–∏–≥—Ä–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ Alembic
- –ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á (APScheduler)
- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π
- –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ–º

## –°—Ç–µ–∫ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π

- Python 3.9+
- [python-telegram-bot](https://python-telegram-bot.org/) (webhooks)
- SQLAlchemy (async)
- Alembic (–º–∏–≥—Ä–∞—Ü–∏–∏)
- APScheduler
- imap-tools
- pandas, openpyxl
- requests
- python-dotenv
- asyncpg, psycopg2-binary

## –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç

1. **–ö–ª–æ–Ω–∏—Ä—É–π—Ç–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π:**
   ```sh
   git clone https://github.com/yourusername/telegram-bot-container-tracker-2.git
   cd telegram-bot-container-tracker-2
   ```

2. **–°–æ–∑–¥–∞–π—Ç–µ –∏ –∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ:**
   ```sh
   python3 -m venv .venv
   source .venv/bin/activate
   ```

3. **–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:**
   ```sh
   pip install -r requirements.txt
   ```

4. **–°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª `.env` –∏ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ:**
   ```env
   DATABASE_URL=postgresql+asyncpg://user:password@host:port/dbname
   TELEGRAM_TOKEN=–≤–∞—à_—Ç–æ–∫–µ–Ω_–±–æ—Ç–∞
   ADMIN_CHAT_ID=–≤–∞—à_telegram_id
   RENDER_EXTERNAL_HOSTNAME=...
   PORT=10000
   ```

5. **–ü—Ä–∏–º–µ–Ω–∏—Ç–µ –º–∏–≥—Ä–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö:**
   ```sh
   alembic upgrade head
   ```

6. **–ó–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞:**
   ```sh
   python bot.py
   ```

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

- `bot.py` ‚Äî –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª –∑–∞–ø—É—Å–∫–∞ Telegram-–±–æ—Ç–∞
- `db.py` ‚Äî –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∏ —Ä–∞–±–æ—Ç–∞ —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
- `config.py` ‚Äî –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
- `handlers/` ‚Äî –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π
- `services/` ‚Äî –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞ –∏ —Å–µ—Ä–≤–∏—Å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
- `alembic/` ‚Äî –º–∏–≥—Ä–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
- `mail_reader.py` ‚Äî –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–∏—Å–µ–º –¥–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–∑—ã
- `scheduler.py` ‚Äî –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –∏ –∑–∞–ø—É—Å–∫ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ –∑–∞–¥–∞—á

## –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–∑—ã

–î–ª—è –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–∑—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è APScheduler.  
–õ–æ–≥–∏–∫–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ –≤ —Å–µ—Ä–≤–∏—Å–∞—Ö –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é.

## –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ

–í –ø—Ä–æ–µ–∫—Ç–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –º–æ–¥—É–ª—å logging –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏–π, –æ—à–∏–±–æ–∫ –∏ —É—Å–ø–µ—à–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π.

## –õ–∏—Ü–µ–Ω–∑–∏—è

MIT

**–ö–æ–Ω—Ç–∞–∫—Ç—ã:**
</file>

<file path="mail_reader.py">
import os
import logging
from imap_tools.mailbox import MailBox
from datetime import datetime
import pandas as pd
from sqlalchemy import text
from db import SessionLocal
from models import Tracking
from logger import get_logger
logger = get_logger(__name__)

EMAIL = os.getenv('EMAIL')
PASSWORD = os.getenv('PASSWORD')
IMAP_SERVER = os.getenv('IMAP_SERVER', 'imap.yandex.ru')
DOWNLOAD_FOLDER = 'downloads'

os.makedirs(DOWNLOAD_FOLDER, exist_ok=True)

async def check_mail():
    logger.info("üì¨ [Scheduler] –ó–∞–ø—É—â–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—á—Ç—ã –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é (–∫–∞–∂–¥—ã–µ 15 –º–∏–Ω—É—Ç)...")
    if not EMAIL or not PASSWORD:
        logger.error("‚ùå EMAIL –∏–ª–∏ PASSWORD –Ω–µ –∑–∞–¥–∞–Ω—ã –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è.")
        return

    try:
        import asyncio
        loop = asyncio.get_running_loop()
        result = await loop.run_in_executor(None, fetch_latest_excel)
        if result:
            filepath = result
            logger.info(f"üì• –°–∫–∞—á–∞–Ω —Å–∞–º—ã–π —Å–≤–µ–∂–∏–π —Ñ–∞–π–ª: {filepath}")
            await process_file(filepath)
        else:
            logger.info("‚ö† –ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö Excel-–≤–ª–æ–∂–µ–Ω–∏–π –≤ –ø–æ—á—Ç–µ, –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–∑—ã –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è.")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–æ—á—Ç—ã: {e}")

def fetch_latest_excel():
    latest_file = None
    latest_date = None
    if EMAIL is None or PASSWORD is None:
        logger.error("‚ùå EMAIL –∏–ª–∏ PASSWORD –Ω–µ –∑–∞–¥–∞–Ω—ã –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è.")
        return None
    with MailBox(IMAP_SERVER).login(EMAIL, PASSWORD, initial_folder='INBOX') as mailbox:
        for msg in mailbox.fetch():
            for att in msg.attachments:
                if att.filename.endswith('.xlsx'):
                    msg_date = msg.date
                    if latest_date is None or msg_date > latest_date:
                        latest_date = msg_date
                        latest_file = (att, att.filename)
        if latest_file:
            filepath = os.path.join(DOWNLOAD_FOLDER, latest_file[1])
            with open(filepath, 'wb') as f:
                f.write(latest_file[0].payload)
            return filepath
    return None

async def process_file(filepath):
    import traceback
    try:
        df = pd.read_excel(filepath, skiprows=3)
        if '–ù–æ–º–µ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞' not in df.columns:
            raise ValueError("['–ù–æ–º–µ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞']")

        records = []
        for _, row in df.iterrows():
            km_left = int(row.get('–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Å—Ç–∞–≤—à–µ–µ—Å—è', 0))
            forecast_days = round(km_left / 600, 1) if km_left else 0.0

            record = Tracking(
                container_number=str(row['–ù–æ–º–µ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞']).strip().upper(),
                from_station=str(row.get('–°—Ç–∞–Ω—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è', '')).strip(),
                to_station=str(row.get('–°—Ç–∞–Ω—Ü–∏—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è', '')).strip(),
                current_station=str(row.get('–°—Ç–∞–Ω—Ü–∏—è –æ–ø–µ—Ä–∞—Ü–∏–∏', '')).strip(),
                operation=str(row.get('–û–ø–µ—Ä–∞—Ü–∏—è', '')).strip(),
                operation_date=str(row.get('–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è –æ–ø–µ—Ä–∞—Ü–∏–∏', '')).strip(),
                waybill=str(row.get('–ù–æ–º–µ—Ä –Ω–∞–∫–ª–∞–¥–Ω–æ–π', '')).strip(),
                km_left=km_left,
                forecast_days=forecast_days,
                wagon_number=str(row.get('–ù–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞', '')).strip(),
                operation_road=str(row.get('–î–æ—Ä–æ–≥–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏', '')).strip()
            )
            records.append(record)

        # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å –ë–î
        async with SessionLocal() as session:
            await session.execute(
                text('CREATE TEMP TABLE IF NOT EXISTS tracking_tmp (LIKE tracking INCLUDING ALL)')
            )
            await session.execute(text('TRUNCATE tracking_tmp'))
            for record in records:
                await session.execute(
                    text(
                        "INSERT INTO tracking_tmp "
                        "(container_number, from_station, to_station, current_station, operation, "
                        "operation_date, waybill, km_left, forecast_days, wagon_number, operation_road) "
                        "VALUES (:container_number, :from_station, :to_station, :current_station, :operation, "
                        ":operation_date, :waybill, :km_left, :forecast_days, :wagon_number, :operation_road)"
                    ),
                    {
                        'container_number': record.container_number,
                        'from_station': record.from_station,
                        'to_station': record.to_station,
                        'current_station': record.current_station,
                        'operation': record.operation,
                        'operation_date': record.operation_date,
                        'waybill': record.waybill,
                        'km_left': record.km_left,
                        'forecast_days': record.forecast_days,
                        'wagon_number': record.wagon_number,
                        'operation_road': record.operation_road,
                    }
                )
            await session.commit()
            await session.execute(text('TRUNCATE tracking'))
            await session.execute(text('INSERT INTO tracking SELECT * FROM tracking_tmp'))
            await session.execute(text('DROP TABLE IF EXISTS tracking_tmp'))
            await session.commit()

        last_date = df['–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è –æ–ø–µ—Ä–∞—Ü–∏–∏'].dropna().max()
        logger.info(f"‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –∏–∑ —Ñ–∞–π–ª–∞ {os.path.basename(filepath)}")
        logger.info(f"üì¶ –ó–∞–≥—Ä—É–∂–µ–Ω–æ —Å—Ç—Ä–æ–∫: {len(records)}")
        logger.info(f"üïì –ü–æ—Å–ª–µ–¥–Ω—è—è –¥–∞—Ç–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ —Ñ–∞–π–ª–µ: {last_date}")
        logger.info(f"üöâ –£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å—Ç–∞–Ω—Ü–∏–π –æ–ø–µ—Ä–∞—Ü–∏–∏: {df['–°—Ç–∞–Ω—Ü–∏—è –æ–ø–µ—Ä–∞—Ü–∏–∏'].nunique()}")
        logger.info(f"üöõ –£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤: {df['–ù–æ–º–µ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞'].nunique()}")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ {filepath}: {e}")
        logger.error(traceback.format_exc())

async def start_mail_checking():
    logger.info("üì© –ó–∞–ø—É—â–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—á—Ç—ã (—Ä—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫)...")
    await check_mail()
    logger.info("üîÑ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—á—Ç—ã –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")
</file>

<file path="bot.py">
from logger import get_logger
logger = get_logger(__name__)

from telegram.ext import (
    Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ConversationHandler
)
from telegram import BotCommand, BotCommandScopeDefault, BotCommandScopeChat
from dotenv import load_dotenv
load_dotenv()

from config import TOKEN, ADMIN_CHAT_ID 
from mail_reader import start_mail_checking
from scheduler import start_scheduler

#from utils.keep_alive import keep_alive
from handlers.user_handlers import (
    start, handle_sticker, handle_message, show_menu,
    menu_button_handler, reply_keyboard_handler, dislocation_inline_callback_handler,
    set_email_command, process_email, cancel_email
)
from handlers.admin_handlers import stats, exportstats, tracking, test_notify
from db import SessionLocal
from handlers.tracking_handlers import (
    tracking_conversation_handler,
    cancel,
    cancel_tracking_confirm
)
from handlers.broadcast import broadcast_conversation_handler

# === –ì–õ–û–ë–ê–õ–¨–ù–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö –û–®–ò–ë–û–ö ===
async def error_handler(update, context):
    logger.error("‚ùóÔ∏è–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: %s", context.error, exc_info=True)

async def set_bot_commands(application):
    user_commands = [
        BotCommand("start", "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"),
        BotCommand("menu", "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"),
        BotCommand("canceltracking", "–û—Ç–º–µ–Ω–∏—Ç—å –≤—Å–µ —Å–ª–µ–∂–µ–Ω–∏—è"),
        BotCommand("set_email", "–£–∫–∞–∑–∞—Ç—å e-mail –¥–ª—è –æ—Ç—á—ë—Ç–æ–≤"),
        BotCommand("email_off", "–û—Ç–∫–ª—é—á–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É –Ω–∞ e-mail"),
    ]
    await application.bot.set_my_commands(
        commands=user_commands,
        scope=BotCommandScopeDefault()
    )
    logger.info("–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –æ–±—ã—á–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")

    admin_commands = user_commands + [
        BotCommand("stats", "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (–∞–¥–º–∏–Ω)"),
        BotCommand("exportstats", "–í—ã–≥—Ä—É–∑–∫–∞ (–∞–¥–º–∏–Ω)"),
        BotCommand("testnotify", "–¢–µ—Å—Ç–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ (–∞–¥–º–∏–Ω)"),
        BotCommand("tracking", "–í—ã–≥—Ä—É–∑–∫–∞ –ø–æ–¥–ø–∏—Å–æ–∫ (–∞–¥–º–∏–Ω)"),
        BotCommand("broadcast", "–†–∞—Å—Å—ã–ª–∫–∞ (–∞–¥–º–∏–Ω)"),
    ]
    await application.bot.set_my_commands(
        commands=admin_commands,
        scope=BotCommandScopeChat(chat_id=ADMIN_CHAT_ID)
    )
    logger.info(f"–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –∞–¥–º–∏–Ω–∞ (ID: {ADMIN_CHAT_ID})")

def main():
    logger.info("üö¶ –°—Ç–∞—Ä—Ç –±–æ—Ç–∞!")
    try:
        keep_alive()
        if TOKEN is None:
            logger.critical("TOKEN must not be None. –ü—Ä–æ–≤–µ—Ä—å config.py")
            raise ValueError("TOKEN must not be None. Please set the TOKEN in your config.")

        application = Application.builder().token(TOKEN).build()

        # --- ConversationHandler –¥–ª—è –∫–æ–º–∞–Ω–¥—ã /set_email ---
        SET_EMAIL = range(1)
        set_email_conv_handler = ConversationHandler(
            entry_points=[CommandHandler("set_email", set_email_command)],
            states={
                SET_EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_email)]
            },
            fallbacks=[CommandHandler("cancel", cancel_email)],
        )
        application.add_handler(set_email_conv_handler)

        async def post_init(application):
            logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è: –∑–∞–ø—É—Å–∫ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ—á—Ç—ã –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞...")
            await start_mail_checking()
            start_scheduler(application.bot)
            await set_bot_commands(application)
            logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")

        application.post_init = post_init

        # ----------- –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ö–µ–Ω–¥–ª–µ—Ä—ã ------------
        application.add_handler(set_email_conv_handler)
        application.add_handler(broadcast_conversation_handler)
        application.add_handler(tracking_conversation_handler())   # ConversationHandler ‚Äî –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –≤—ã—à–µ
        application.add_handler(CallbackQueryHandler(menu_button_handler, pattern="^(start|dislocation|track_request)$"))
        application.add_handler(CallbackQueryHandler(dislocation_inline_callback_handler, pattern="^dislocation_inline$"))
        application.add_handler(CommandHandler("menu", show_menu))
        application.add_handler(CommandHandler("start", start))
        application.add_handler(CommandHandler("canceltracking", cancel))
        application.add_handler(CommandHandler("stats", stats))
        application.add_handler(CommandHandler("exportstats", exportstats))
        application.add_handler(CommandHandler("tracking", tracking))
        application.add_handler(CommandHandler("testnotify", test_notify))
        application.add_handler(CallbackQueryHandler(cancel_tracking_confirm, pattern="^cancel_tracking_"))
        application.add_handler(MessageHandler(
            filters.Regex("^(üì¶ –î–∏—Å–ª–æ–∫–∞—Ü–∏—è|üîî –ó–∞–¥–∞—Ç—å —Å–ª–µ–∂–µ–Ω–∏–µ|‚ùå –û—Ç–º–µ–Ω–∞ —Å–ª–µ–∂–µ–Ω–∏—è)$"),
            reply_keyboard_handler
        ))
        application.add_handler(MessageHandler(filters.Sticker.ALL, handle_sticker))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))   # –í—Å–µ–≥–¥–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–º!

        # === –ì–õ–û–ë–ê–õ–¨–ù–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö –û–®–ò–ë–û–ö ===
        application.add_error_handler(error_handler)

        logger.info("–í—Å–µ —Ö–µ–Ω–¥–ª–µ—Ä—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã, –±–æ—Ç –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!")

        application.run_polling()

        logger.info("–†–∞–±–æ—Ç–∞ –±–æ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ.")

    except Exception as e:
        logger.critical("üî• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: %s", e, exc_info=True)

if __name__ == "__main__":
    main()
</file>

<file path="db.py">
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base
from sqlalchemy import select, delete, update
from config import DATABASE_URL

if DATABASE_URL is None:
    raise ValueError("DATABASE_URL must be set and not None")

engine = create_async_engine(
    DATABASE_URL,
    future=True,
    pool_recycle=300,    # –û–±–Ω–æ–≤–ª—è—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
    pool_pre_ping=True,  # –ü–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º ‚Äî –ø–∏–Ω–≥—É–µ–º
)
SessionLocal = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

Base = declarative_base()

from models import TrackingSubscription, Tracking, User, Stats
async def get_all_user_ids():
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö user_id –∏–∑ —Ç–∞–±–ª–∏—Ü—ã stats.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.
    """
    async with SessionLocal() as session:
        result = await session.execute(select(Stats.user_id).distinct())
        user_ids = [row[0] for row in result.fetchall() if row[0] is not None]
        return user_ids

# ====== –î–æ–±–∞–≤–ª–µ–Ω–æ –¥–ª—è handlers/user_handlers ======

async def get_tracked_containers_by_user(user_id):
    """
    –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    """
    async with SessionLocal() as session:
        result = await session.execute(
            select(TrackingSubscriptions.containers).where(TrackingSubscriptions.user_id == user_id)
        )
        row = result.scalar_one_or_none()
        return row if row else []

async def remove_user_tracking(user_id):
    """
    –£–¥–∞–ª–∏—Ç—å –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–æ—Ç–ø–∏—Å–∫–∞ –æ—Ç –≤—Å–µ—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤).
    """
    async with SessionLocal() as session:
        await session.execute(
            delete(TrackingSubscriptions).where(TrackingSubscriptions.user_id == user_id)
        )
        await session.commit()

async def set_user_email(telegram_id, username, email):
    """
    –ü—Ä–∏–≤—è–∑–∞—Ç—å –∏–ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å email –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç ‚Äî –æ–±–Ω–æ–≤–∏—Ç—å. –ò–Ω–∞—á–µ ‚Äî —Å–æ–∑–¥–∞—Ç—å.
    """
    async with SessionLocal() as session:
        result = await session.execute(
            select(User).where(User.telegram_id == telegram_id)
        )
        user = result.scalar_one_or_none()
        if user:
            await session.execute(
                update(User).where(User.telegram_id == telegram_id)
                .values(username=username, email=email)
            )
        else:
            session.add(User(telegram_id=telegram_id, username=username, email=email))
        await session.commit()
</file>

</files>
